---
title: 隐蔽的恶意代码启动
date: 2019-11-12 10:31:28
tags: windows病毒分析
---

# 本篇学习重点

## 进程注入

将恶意DLL注入到另外一个正在运行的进程中

### DLL注入

通过创建远程线程调用LoadLibraryW来加载恶意DLL

**注入流程：**

1. 获取受害进程句柄。CreateToolhelp32Snapshot、Process32First、Process32Next遍历进程获取PID，然后用OpenProcess获取进程句柄
2. 获取LoadLibary函数地址。GetModuleHandle获取kernel32.dll模块句柄，然后GetProcAddress获取该模块中LoadLibraryW函数的地址(*Windows 系统中，LoadLibraryW 函数位于 kernel32.dll 中，并且系统核心 DLL 会加载到固定地址，所以系统中所有进程的 LoadLibraryW 函数地址是相同的*)
3. 将恶意DLL路径名称写入受害进程内存空间中。WriteProcessMemory 
4. 创建远程线程到受害进程中。CreateRemoteThread，用到了上面获取的参数：受害进程句柄、LoadLibraryW 函数地址以及其参数(恶意DLL的名称)

### 直接注入

将恶意代码注入到另外一个正在运行的进程中

**注入流程：**

1. 获取受害进程句柄。CreateToolhelp32Snapshot、Process32First、Process32Next遍历进程获取PID，然后用OpenProcess获取进程句柄
2. 将恶意代码需要的参数数据写入远程进程内存空间中。VirtualAllocEx、WriteProcessMemory
3. 将恶意代码的指令写入远程进程内存空间中。VirtualAllocEx、WriteProcessMemory
4. 创建远程线程到受害进程中。CreateRemoteThread，用到了上面获取的参数：受害进程句柄、恶意代码启动地址以及其需要的参数数据地址

## 进程替换

将恶意代码的所有可装载段替换掉傀儡进程内存空间的所有段(可以避免注入DLL引起进程崩溃情况)

**替换流程：**

1. 创建一个挂起进程最为傀儡进程。CreateProcessA（CREATE_SUSPENDED）
2. 释放傀儡进程中映射好的内存。NtUnmapViewOfSection
3. 申请一块内存空间准备写入恶意代码。VirtualAllocEx
4. 写入恶意代码到申请的内存空间中。WriteProcessMemory
5. 设置线程入口点为我们恶意代码的内存地址。SetThreadContext
6. 恢复傀儡进程的运行。ResumeThread开始恢复运行傀儡进程执行恶意代码

## 钩子注入

通过拦截Windows消息来注入DLL并且调用特定的挂钩函数

* 局部钩子：可以对远程进程中的特定线程进行挂钩，但通常我们都是对特定进程的主线程进行挂钩
* 全局钩子：对同一个桌面上所有应用程序的所有线程进行挂钩，

**注入流程：**

1. 获取恶意DLL的句柄。LoadLibrary
2. 获取恶意DLL导出函数地址作为钩子例程。GetProcAddress
3. 获取远程进程的主线程ID(局部)或者使用0(全局)。Thread32First、Thread32Next
4. 创建钩子。SetWindowsHookEx

## Detours

添加新段".detour"来创建新的导入表加载恶意DLL，并修改PE文件使导入表入口指向新的导入表位置

## APC注入

*Asynchronous Process Call*：每个线程都有APC队列，当线程调用WaitForSingleObjectEx、WaitForMutipleObjectEx、SleepEx等候处于可警告的等待状态，就会开始处理APC

* 用户模式下APC注入

**注入流程：**

1. 获取受害线程句柄。OpenThread
2. 获取APC函数地址以及函数参数地址。对应参数pfnAPC、dwData
3. 将APC函数排入队列。 

* 内核模式下APC注入：恶意驱动和Rootkit在用户空间中执行代码

**注入流程：**

1. KeInitializeApc获取一个用户模式下的APC（KAPC结构）。第6个参数非0，第七个参数(ApcMode)为1，第二个参数包含受害线程
2. 将获取的KAPC结构体排入目标线程队列中。KeInsertQueueApc

# 目标

通过练习样本学习多种恶意代码隐藏执行技术

# 分析流程

1. 基础静态分析
2. 高级动态静态结合分析

# 实践

## 实例1

Lab12-01.exe

Lab12-01.dll

### 基础静态分析

#### Lab12-01.exe

DLL注入，可能是将Lab12-01.dll注入到explorer.exe进程中

```
导入函数：
WriteProcessMemory
VirtualAllocEx
OpenProcess
CreateRemoteThread
LoadLibraryA

字符串：
explorer.exe
Lab12-01.dll
```

#### Lab12-01.dll

线程操作

```
导入函数：
CreateThread
```

### 高级分析

枚举进程

![1573556098804](1573556098804.png)

获取explorer.exe进程的句柄

![1573556154060](1573556154060.png)

![1573556199700](1573556199700.png)

DLL注入当前目录下的Lab12-01.dll文件

![1573556291051](1573556291051.png)

而在Lab12-01.dll文件中，入口处创建线程来进行每隔1分钟的无限弹窗

![](1574060532935.png)

### 小结

该样本利用进程注入中的DLL注入技术，将恶意DLL注入到explorer.exe进程中

**清除病毒：**

* 重启explorer.exe进程
* 删除Lab12-01.exe、Lab12-01.dll文件

## 实例2

Lab12-02.exe

### 基础静态分析

资源加载操作

可能是对svchost.exe进程进行了进程替换技术，但是并未看见zwUnmapViewOfSection导入函数

```
导入函数：
LoadResource
FindResourceA
VirtualAlloc
WriteProcessMemory
VirtualAllocEx
ResumeThread

字符串：
\svchost.exe
```

### 高级分析

解密资源

![1574061573012](1574061573012.png)

解密之后，资源头部数据出现MZ，标准的PE文件头，我们这里可以右键选中这块内存中的数据备份到文件，稍后分析

![1574061738220](1574061738220.png)

将刚解密的PE文件地址和"C:\Windows\system32\svchost.exe"作为参数传入函数

![1574062046361](1574062046361.png)

1.创建一个挂起的傀儡进程svchost.exe

2.卸载傀儡进程在内存中的映像。这里是通过加载ntdll.dll来调用NtUnmapViewOfSection函数的，所以导入表中没有改函数

3.申请一块内存准备存放恶意代码

4.将恶意代码写入申请的内存中，先写头在遍历节头表将文件偏移的数据写到虚拟地址处

5.修改线程上下文结构体，将恶意代码这个PE文件中内存基址和入口点地址写进结构体

![1574073091403](1574073091403.png)

至此，Lab12-02.exe基本分析完毕，主要行为就是通过进程替换来执行资源中加密过的PE文件，下面我们分析这个解密后的PE文件

1.隐藏命令行

2.下键盘记录的全局钩子

3.当接收到退出消息后解除全局钩子

![1574136800954](1574136800954.png)

将程序标题文本以及对应键盘输入输出到*practicalmalwareanalysis.log*文件中

![1574138400961](1574138400961.png)

### 小结

该样本通过进程替换技术将资源节中加密后的恶意PE文件加载进svchost.exe进程的内存中，接着钩子注入技术进行全局键盘记录。

但是原始样本在windows7 32bit上会报错svchost.exe程序不能执行，而从内存中拷出来的PE文件是可以执行并挂钩成功的

# 参考

【1】[DLL 注入之远程线程注入](http://0x4c43.cn/2017/0510/dll-injection-remote-thread/)

【2】[Dll注入：Windows消息钩子注入](https://www.cnblogs.com/HsinTsao/p/6457877.html)