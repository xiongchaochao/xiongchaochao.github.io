---
title: windows样本高级动态分析
date: 2019-10-14 10:46:54
tags: windows病毒分析
---

# 前置知识

## 用户模式调试和内核模式调试区别：
在用户模式调试普通应用程序的时候，因为系统会将每个应用进程进行隔互不影响，所以你个被调试的程序下断点并不影响其他程序和系统的运行。

但是内核调试就不一样的，系统只有一个内核，所有应用程序的执行都是在底层由内核来调度的，如果给内核下断点，整个系统就停住了，所以需要两个系统，一个运行调试器另一个运行被调试的代码。

## 软件断点

**实现方式**：通过重写指令首个字节为0xcc，即"INT 3"指令，这个指令专门供调试器所使用，一旦触发操作系统产生异常接着讲控制权交给调试器。

内核模式会限制软件断点的数量，用户模式不限制

## 硬件断点

x86支持硬件断点

**实现方式：**利用专门硬件寄存器。处理器执行每一条指令的时候，硬件都会检测指令的指针是否和断点相等，而不关心指令内容。

**优点：**

* 所以，遇见修改自身代码的样本时，软件断点可能就被修改了，但是地址不会改变，所以硬件断点依然生效
* 可以设置访问中断这种模式的断点，也就是说，不是只有执行到断点地址处才会中断，而是对该地址的读、写都可以中断下来

**缺点：**

* 只有四个硬件寄存器存储硬件断点

* 容易被运行的程序修改。CPU芯片虽然有8个调试寄存器，但是这个前四个DR0~DR3来储存断点地址，调试控制寄存器DR7保存DR0~DR3的值是否有效，以及他们表示读写或执行断点的信息，病毒可以修改这些寄存器来进行干扰。

  幸亏X86芯片组有防御上面干扰的能力，可以设置DR7的通用探测标志位，任何执行mov指令访问DR7寄存器的操作都会触发断点，让你可以查看DR7的改变情况，虽然只能监控mov指令

## 条件断点

首先它是软件断点，其次它需要条件才能触发。适合小段代码使用

**缺点：**如果在经常被访问的指令上下条件断点，会导致程序运行速度明显减缓，甚至于不能运行。

## 内存断点

**内存访问断点：**通过修改内存页属性，一旦访问或者读写到该内存也就会触发异常，调试器处理该异常，然后判断是否和断点地址相同，不同就放行

OD支持在内存面板或者内存映射面板中对一部分内存下断点。只准设置一个断点，后面的会覆盖前面的。效率很低，因为是修改一个内存页的属性，断点位置很大。

**内存硬件断点：**就是硬件断点

## 异常

异常是调试器获取程序控制权的基本方式。

但本质上，出了断点产生的异常外，还有其他开发过程中无意中留下的非法内存访问、除0操作异常，这些异常就是由于开发中不严谨的Bug引起的，调试器就是为了探测出这些异常，让那些不可控异常消除掉，或者可控起来。

### 首次和二次异常处理

调试器通常有两次机会来处理同一个异常。

**背景**：一个存在除0异常的被调试的程序

**首次异常处理：**调试器调试这个程序后，执行到除0操作处异常触发，调试器可以选择自己处理，或者转给被调试的应用程序处理。

**第二次异常处理：**上一步里，调试器选择将异常转给被调试的程序，这种情况下，如果程序没有注册异常处理函数，也就是处理不了这种异常，调试器就获得了第二次处理的机会，如果不处理程序就会崩溃。

### 常见异常

* INT 3断点：即上面介绍过的"INT 3"指令，这是一种"trap"类硬件异常，操作系统会保存异常的"下文"，在调试器处理完异常后，就会执行到"下文"也就是下一条指令中去
* 单步调试：也就是OD的F8键，也是一种"trap"类硬件异常，主要有标志寄存器的陷阱标志(trap flag)来实现，标志寄存器置位后，处理器每执行一条指令都会触发异常。
* 访问无权限访问的地址，会产生内存冲突memory-access violation
* 在非特权模式下执行一些特权命令

## 分析shellcode

将shellcode二进制复制到内存属性为Priv的00区域中去，然后设置EIP到shellcode处进行调试

# 概述

本片文章通过对Lab07_03.exe分析，学习OllyDbg来进行高级动态分析

# 目标

结合动态调试来分析样本

# 流程

1.基础静态分析

2.高级静态动态结合分析

# 实践过程

## 实例

Lab09-01.exe

### 基础静态分析

样本可能存在：

* 创建服务
* 文件操作
* socket网络通信
* 注册表操作
* 创建进程

```
导入函数：
1.CreateServiceA
2.CopyFileA
WriteFile
DeleteFileA
3.115 (WSAStartup)
19 (send)
23 (socket)
16 (recv)
4.RegSetValueExA
5.CreateProcessA

字符串：
SOFTWARE\Microsoft \XPS
DOWNLOAD
cmd.exe
/c del 
http://www.practicalmalwareanalysis.com
 HTTP/1.0\r\n\r\n
UPLOAD
 >> NUL
```

### 高级动态静态结合分析

根据是否传入命令行参数来决定样本的执行。如果不传参数，进入sub_401000函数，如果这个函数返回值为0就进入sub_402410函数，另外一种情况，如果返回值不为0，则直接跳到结尾，返回结果为0。下面进行第一步，分析sub_401000

![1571131371574](1571131371574.png)

寻找注册表项"SOFTWARE\\Microsoft \\XPS"的键值"Configuration"，如果找到则返回1，接着跳出当前函数并且跳到函数结尾，返回0。

如果找不到该注册表键值，则返回为0，进入sub_402410函数

![1571132060984](1571132060984.png)

删除当前文件，这里也可以直接定位到ShellExecuteA的参数传入的地方，直接查看需要执行的命令内容

![1571132808362](1571132808362.png)

![1571133048818](1571133048818.png)

#### 修补patch

所以分析导致里我们发现如果程序要正常执行需要给一个参数才可以，这里我们用另一个方法，直接修改内存中的汇编代码，有多种修改方法：

1.我们空格跳转指令，将其改成参数数量和0进行比较，由于自身程序占一个参数数量，所以cmp结果不为0，修改Z标志位为0

![1571134007134](1571134007134.png)

2.将条件跳转指令JNZ改成JZ，都是一字节指令不会影响整体指令。

过掉第一个条件，继续向下分析。

如果不传入参数并且存在注册表键值"SOFTWARE\\Microsoft \\XPS"\Configuration"的情况下，执行进sub_402360函数

进入while循环，首先将注册表键值的数据存入四个本地变量，接着将其作为参数传入sub_401E60

![1571217170581](1571217170581.png)

如果sub_401E60返回结果不为0就会跳转到结尾返回1，继续深入，分析sub_401E60，寻找满足条件

![1571218711204](1571218711204.png)

读取域名到name变量、读取80对应16进制数0x50到hostshort变量，然后在sub_401D80函数中，由于是一些逻辑运算暂时跳过，接着根据配置来创建socket连接，这一步我们因为域名实效，将返回值后的跳转patch掉

![1571219843372](1571219843372.png)

![1571221373239](1571221373239.png)

构造http请求报文发送到指定域名，用来获取返回报文

![1571222702986](1571222702986.png)

然后截取返回报文中下面途中两个字符串之间的数据存放到传入的参数v14中去

![1571223793560](1571223793560.png)

接着分析返回数据：

* sleep：根据紧跟在后面的数值程序进行睡眠

![1571224748179](1571224748179.png)

* upload：文件上传：socket连接远程服务器接收数据，根据upload后面的文件名，创建并将数据写入文件内，接着修改文件时间跟kernel32.dll同步

![1571225171930](1571225171930.png)

* download：文件下载：根据紧跟在后面的文件名，读取特定文件并把数据发送回远程服务器

![1571225365486](1571225365486.png)

* CMD：命令执行：获取报文中的命令，执行完毕后将输出发送回远程服务器

![1571225570026](1571225570026.png)

然后就是不断反复执行上面的交互操作，直到出错退出。到此我们关于不带命令的分析就结束了，是常见的后门操作，需要配合注册表键值"SOFTWARE\\Microsoft \\XPS"\Configuration"进行远程服务器的连接，根据返回报文进行操作。

![1571225706884](1571225706884.png)

这里我们分析给命令行传参的情况：因为样本本身占一个参数，所以argv[arc-1]取的就是传入最后一个参数的地址，将其作为sub_402510的参数进行调用，并且如果返回结果为0就执行sub402410，上面分析过，删除自身并结束，所以我们需要分析sub402410函数，让其返回值不为0

![1571134498285](1571134498285.png)

第一步if判断，如果最后一个命令行参数的长度不等于4就会跳转到结尾，返回0，这一步可以通过写两个参数，最后一个命令行参数随意些长度为4的字符，或者调试的时候patch绕过

第二步：绕过第一步，首先判断参数首个字符是否为"a"，如果不是就会跳转到结束，所以需要绕过：4字节参数首个字符为a或者动态patch

![1571200878352](1571200878352.png)

第三步：绕过第二步，接着需要满足命令行参数的第二个字符比第一个字符大一才可以避免跳出，绕过方式同上。判断第三个字符是否等于"c"，第四个字符是否比第三个字符大1，满足上面条件就返回1

![1571208550481](1571208550481.png)

​	为了调试更接近真实样本运行，并且防止patch之后影响指令判断（movsx）我们填写真实条件来调试，上面总结的条件有：命令行参数>1，最后一个命令行参数为"abcd"

当第二个命令行参数为"-in"且命令行参数数量为3时，将文件名"Lab09-01"放入变量ServiceName里，接着执行进sub_402600函数

![1571210485738](1571210485738.png)

![1571211011571](1571211011571.png)

sub_402600函数：创建服务Lab09-01，将Lab09-01.exe复制到"C:\Windows\system32\Lab09-01.exe"作为服务的可执行文件路径并且修改该文件的修改日期为kernel32.dll的修改日期

![1571212084572](1571212084572.png)

![1571213128738](1571213128738.png)

接着将一串带有域名的字符写进注册表"SOFTWARE\\Microsoft \\XPS"

![1571213711579](1571213711579.png)

上面这些是第二个命令行参数为"-in"且命令行参数数量为3时发生的行为，还有另一种情况，当命令行参数为4的时候会将第三个命令行参数作为服务名来进行上面的操作

![1571214052546](1571214052546.png)

当第二个命令行参数不是"-in",而是"-re"的时候，删除服务Lab09-01，删除对应二进制可执行文件"C:\Windows\system32\Lab09-01.exe"，并且将注册表清空

![1571215095130](1571215095130.png)

![1571215119810](1571215119810.png)

当第二个参数是"-c"时，加上可执行文件自己的第一个参数，总共需要7个参数才不会删除自己。再除去第二个参数"-c"，最后一个参数"abcd"，第3~6的命令行参数作为参数写入注册表"SOFTWARE\\Microsoft \\XPS"\Configuration"

![1571216490697](1571216490697.png)

当第二个参数是"-cc"时，首先需要满足总共3个命令行参数的条件，接着需要将注册表键值"SOFTWARE\\Microsoft \\XPS"\Configuration"中的数据提取到4个本地变量中

然后从注册表获取的数据和一串占位符传入函数sub_402E7E，一般不是打印输出就是字符串拼接，我们在调试界面上单步一下查看输出界面，从下面图中可以看出这是一个打印函数

![1571217386136](1571217386136.png)

![1571217509986](1571217509986.png)

### 总结

不带参数：

1. "SOFTWARE\\Microsoft \\XPS"\Configuration"键值对应配置信息，获取远程服务器的地址，构造HTTP请求报文，发送到远程服务器用来获取相应报文
2. 解析相应报文，执行对应操作
   * sleep睡眠
   * upload上传文件到本地
   * download读取本地文件并发送到远程服务器
   * CMD执行指定命令并返回结果信息
   * 不做任何操作

带参数的操作：

| 命令行参数             | 行为                                                         |
| ---------------------- | ------------------------------------------------------------ |
| -in abcd               | 创建服务Lab09-01长期驻留，创建注册表存储配置                 |
| -in <serviceName> abcd | 创建服务<serviceName>长期驻留，创建注册表存储配置            |
| -re abcd               | 删除服务Lab09-01，删除文件"C:\Windows\system32\Lab09-01.exe"，将注册表键值置0 |
| -re <serviceName> abcd | 删除服务<serviceName>，删除文件"C:\Windows\system32\Lab09-01.exe"，将注册表键值置0 |
| -c                     | 编写注册表键值"SOFTWARE\\Microsoft \\XPS"\Configuration"     |
| -cc                    | 打印注册表键值"SOFTWARE\\Microsoft \\XPS"\Configuration"     |

# 补充知识

## 汇编指令

* repne：不相等的时候重复。
* repe：相等的时候重复
* scasb：一直重复搜索到EDI字符串末尾的00，所以repne scasb就是循环字符串edi，获取字符串长度
* not ecx：得到搜索次数，也就是字符串的完整长度
* dec ecx：-1得到字符串不包含末尾0的长度