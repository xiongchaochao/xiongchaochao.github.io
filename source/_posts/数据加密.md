---
title: 数据加密
date: 2019-11-19 17:55:39
tags: windows病毒分析
---

# 知识引入

## 恶意代码加密的目的

* 隐藏网络通信数据
* 隐藏配置信息、字符串、代码来增加分析难度
* 免杀
* 等

## 简单加密

### 凯撒密码

单个字符在字母表中右移3位

### XOR

数据中的每个字符和密钥字符进行异或。容易出现数据中00全部被异或成密钥字符，所以常出现于shellcode中的保留NULL的XOR：当字符为00或者密钥字符时不进行异或

### 其他一些简单加密策略

* ADD、SUB：不可逆需要同时使用
* ROL、ROR：不可逆需要同时使用
* ROT：原始凯瑟密码
* Multibyte：使用一定数量(4个或8个)字符异或一块数据
* 链或者环：将数据分为一块一块的，前一块加密过的数据作为后一块数据的密钥

### Base64

将二进制数据转成ascii码字符串。标准过程：使用24位数据(3字节长度)分成4个6位数据，这样得出4个索引值在一串64长度的字符串中取值。所以可以自定义修改这个64长度的字符串来自定义Base64加密效果

## 常见加密算法

现代加密算法引入指数级的计算能力，让破解难度近乎不可能

### 识别方法

* 加密常量查找：IDA插件-FindCrypt2、PEID插件：Kcypto ANALyzer
* IDA熵值插件

## 自定义加密

多种简单加密策略结合起来。

### 识别方法

定位到输入、输出代码附近

## 解密

### 自解密

使用程序中自带解密函数完成解密

### 自己编写解密函数

# 实践

## 实例1

Lab13-01.exe

### 基础静态分析

1.读取资源

2.访问网页文件，网址可能被加密了

3.写文件操作

4.存在Base64加密算法

```
导入函数：
LoadResource
FindResourceA
InternetOpenUrlA
InternetReadFile
WriteFile

字符串：
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
http://%s/%s/
```

### 高级分析

对资源数据进行异或0x3B解密

![](1574218576255.png)

![](1574218604936.png)

解密出C2地址 www.practicalmalwareanalysis.com

![1574218828576](1574218828576.png)

接着用户本机主机名称传入函数中进行算法运算

函数中的加密算法逻辑：

1. 循环操作，不断从数据中读取3字节数据，直到读取完毕，如果最后读取的数据不够3字节则用0填充，然后将读取到的数据进行处理

2. 每次读取数据的处理过程1：

   1. 第一个字节右移2位(由于ecx高位为0，所以该算数右移同逻辑右移一样)得到一，个6位长度的值，以该值作为索引取字符串中的一个字符存放到第二个参数的首位

   2. 当读取到的数据数据大于一个字符时：

      1. 数据第一个字节保留低位的2位，然后让这两位逻辑左移4位，即作为第5、6位，然后数据第二个字节保留高4位，然后右移4位，即作为低4位，两者结合组成一个6位索引值从特定字符串中取一个字符存放到第二个参数的第二位
      
   3. 当读取到的数据数据小于等于1个字符时：

      1. 用"="存放到第二个参数的第二位

   4.当读取到的数据数据大于2个字符时：

      1. 数据第二字节的低四位左移2位，数据第三字节取第7、8位然后右移6位作为最低的两位和前面的四位结合组成一个6位索引值从特定字符串中取一个字符存放到第二个参数的第三位

   5. 当读取到的数据数据小于等于2个字符时：

      1. 用"="存放到第二个参数的第3位

3. 每次读取数据的处理过程2:
   
   1. 将完成处理过程1后的3字节数据放入该函数第二参数中

从处理过程1的逻辑可以看出是Base64加密过程

![1574334874127](1574334874127.png)

![1574334901042](1574334901042.png)

将Base64加密过的主机名和和C2地址组合成一个特定URL

![1574391355255](1574391355255.png)

然后访问该网页，如果返回的数据的前4字节数据为0x6F，则返回1并睡眠30s后结束，否则返回0，睡眠30.5s后继续无限循环的访问该网址直到返回0x6F或者程序异常退出为止

![1574392569042](1574392569042.png)



### 小结

该样本涉及到的加密算法有：

* 简单加密：XOR、Base64加密

通过XOR解密出资源文件中的C2地址，然后用Base64加密主机名，接着组合成一个特定URL进行访问，等待远程回应否则一直进行请求

## 实例2

Lab13-02.exe

### 基础静态分析

截图操作，可能写入到格式化字符串temp%08x中

```
导入函数：
CreateCompatibleBitmap
BitBlt
GetDIBits
CreateCompatibleDC
CreateFileA
WriteFile

字符串：
temp%08x
```

### 高级分析

无限循环操作

![1574764702806](1574764702806.png)

屏幕截图行为

![1574764736933](1574764736933.png)

截图加密，存在多种简单加密运算如：异或、移位操作，所以判定为自定义加密

![1574764766499](1574764766499.png)

将加密过的截图数据写入文件

![1574764812321](1574764812321.png)

## 实例3

Lab13-03.exe

### 基础静态分析

1.存在网络操作，涉及到www[.]practicalmalwareanalysis[.]com

2.文件操作

3.可能会通过CreateProcessA来创建后门

4.存在自定义Base64加解密

```
导入函数：
9 (htons)
4 (connect)
115 (WSAStartup)
WriteFile
ReadFile
CreateProcessA

字符串：
CDEFGHIJKLMNOPQRSTUVWXYZABcdefghijklmnopqrstuvwxyzab0123456789+/
cmd.exe
www.practicalmalwareanalysis.com
```

### 高级分析

创建和远程地址www[.]practicalmalwareanalysis[.]com:8910创建套接字

![1575344267342](1575344267342.png)

创建cmd进程并将标准输入、输出、错误流绑定到管道读写端上

![1575343341866](1575343341866.png)

创建两条线程，分传入参数套接字和管道写入端来、套接字和管道读取端将套接字绑定到本地cmd进程上实现后门shell 的建立

![](1575343734801.png)

第一条线程不断从套接字上读取最大0x400字节数据并经过涉及到Base64的处理后写入到管道的写入端中。

![1575345481144](1575345481144.png)

Base64的处理过程是自定义Base64解密算法：每次从套接字中取4字节数据，然后在自定义字符串"CDEFGHIJKLMNOPQRSTUVWXYZABcdefghijklmnopqrstuvwxyzab0123456789+/"中获取对应索引值，最后还原成一个最长24位长度的数据。

接着进行规范的Base64解密过程

![1575347739072](1575347739072.png)

第二条线程从管道读取端读取数据，然后通过AES加密处理将数据写到套接字中，传到远程服务器

![1575349059868](1575349059868.png)

我们复现这个过程，从C2地址接收到Base64自定义加密过的命令，解密执行后将结果返回，通过wireshark可以抓到数据流

![1575357709648](1575357709648.png)

根据Base64自定义加密流程写出解密脚本，可以得到解密结果"dir"命令

```python
import string
import base64

s = ""

tab = "CDEFGHIJKLMNOPQRSTUVWXYZABcdefghijklmnopqrstuvwxyzab0123456789+/"
b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

ciphertext = "BInaEI=="

for ch in ciphertext:
	if ch in tab:
		s += b64[string.find(tab, str(ch))]
	elif ch == "=":
		s += "="
		
print base64.decodestring(s)
```

然后编写AES解密脚本解密客户端发送的内容

```python
from Crypto.Util.Padding import pad
from Crypto.Cipher import AES
import binascii

raw  = '''
37 f3 1f 04 51 20 e0 b5  86 ac b6 0f 65 20 89 92
e8 79 4f b2 76 5d fd fd  b6 06 dd 16 7f 43 99 2d
cc d8 0b 7f 14 0e 35 b9  30 87 53 bf 42 55 c4 7f
'''

ciphertext = binascii.unhexlify(raw.replace(' ', '').replace("\n", ""))
obj = AES.new("ijklmnopqrstuvwx", AES.MODE_CBC)
print "Plaintext is : \n" + obj.decrypt(pad(ciphertext, 16))
```

# 补充知识

## sar

算数右移，保留操作数的符号位，也就是用符号位来补充

eg:

* sar 1000 0000, 1 ==> 1100 0000
* sar 1000 0000, 2 ==> 1110 0000

所以当符号位为1时，算数右移就等于逻辑右移在或上一个值，这个值从高位到低位1的数量取决于移动位数

## 截图功能By系统API

1. 获取显示屏高度和宽度

```c
GetSystemMetrics(0); 	//SM_CXSCREEN显示屏宽度
GetSystemMetrics(1); 	//SM_CYSCREEN显示屏高度
```

2. 选择需要截图的窗口来获取其设备环境DC

```c
hWnd = GetDesktopWindow();					//整个桌面对应的窗口句柄
HDC hDC = GetDC(hWnd);						//指定窗口的设备环境
```

3. 创建兼容指定设备的内存设备环境、位图，接着把位图选入内存设备环境准备画图

```c
HDC hdc = CreateCompatibleDC(hDC);		//创建内存设备环境
HGDIOBJ h = CreateCompatibleBitmap(hDC, dwScreenWidth, dwScreenHight);	//创建位图
SelectObject(hdc, h);					//把位图选入指定的内存设备环境中来进行画图
```

4. 填写位图头结构体

```c
	bi.biSize = sizeof(BITMAPINFOHEADER);	//填写位图头结构
	bi.biWidth = bmpScreen.bmWidth;
    bi.biHeight = bmpScreen.bmHeight;
    bi.biPlanes = 1;
    bi.biBitCount = 32;
    bi.biCompression = BI_RGB;
    bi.biSizeImage = 0;
    bi.biXPelsPerMeter = 0;
    bi.biYPelsPerMeter = 0;
    bi.biClrUsed = 0;
    bi.biClrImportant = 0;
```

5. 申请堆内存，写入位图数据

```c
dwBmpSize = ((bmpScreen.bmWidth * bi.biBitCount + 31) / 32) * 4 * bmpScreen.bmHeight;		//位图大小
	hDIB = GlobalAlloc(GHND, dwBmpSize);	//申请堆内存填写位图数据
    lpbitmap = (char *)GlobalLock(hDIB);
	//将截图数据写到堆内存中
	GetDIBits(
        hDC,  // 设备环境句柄
       (HBITMAP)h,  // 位图句柄
        0,          // 指定检索的第一个扫描线
        (UINT)bmpScreen.bmHeight, // 指定检索的扫描线数
        lpbitmap,   // 指向用来检索位图数据的缓冲区的指针
        (BITMAPINFO *)&bi, // 该结构体保存位图的数据格式
        DIB_RGB_COLORS // 颜色表由红、绿、蓝（RGB）三个直接值构成
    );
```

6. 将内存中的位图数据写入文件

```c
wsprintf(FilePath, "%s\\%s.bmp", "c:\\Users\\xxx\\Desktop\\", "dump");
	// 创建一个文件来保存文件截图
    hFile = CreateFile(
                FilePath,
                GENERIC_WRITE,
                0,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
            );
	// 将 图片头(headers)的大小, 加上位图的大小来获得整个文件的大小
    int dwSizeofDIB = dwBmpSize + sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER);
 
    // 设置 Offset 偏移至位图的位(bitmap bits)实际开始的地方
    bmfHeader.bfOffBits = (DWORD)sizeof(BITMAPFILEHEADER) + (DWORD)sizeof(BITMAPINFOHEADER);
 
    // 文件大小
    bmfHeader.bfSize = dwSizeofDIB;
 
    // 位图的 bfType 必须是字符串 "BM"
    bmfHeader.bfType = 0x4D42; //BM	
 
    DWORD dwBytesWritten = 0;
    WriteFile(hFile, (LPSTR)&bmfHeader, sizeof(BITMAPFILEHEADER), &dwBytesWritten, NULL);
    WriteFile(hFile, (LPSTR)&bi, sizeof(BITMAPINFOHEADER), &dwBytesWritten, NULL);
    WriteFile(hFile, (LPSTR)lpbitmap, dwBmpSize, &dwBytesWritten, NULL);
```

7. 释放资源

```c
 // 解锁堆内存并释放
    GlobalUnlock(hDIB);
    GlobalFree(hDIB);
 
    // 关闭文件句柄
    CloseHandle(hFile);
	GlobalUnlock(hDIB);
	GlobalFree(hDIB);
	ReleaseDC(hWnd, hDC);
	DeleteDC(hdc);
	DeleteObject(h);
```

**完整代码**

```c
#include <windows.h>


void main()
{
	int dwScreenWidth;
	int dwScreenHight;
	HWND hWnd;
	BITMAP bmpScreen;
	BITMAPINFOHEADER bi;
	int dwBmpSize;
	HANDLE hDIB;
	CHAR *lpbitmap;
	BITMAPFILEHEADER bmfHeader;
	HANDLE hFile;
	CHAR FilePath[MAX_PATH];

	dwScreenWidth = GetSystemMetrics(0);	//宽度
	dwScreenHight = GetSystemMetrics(1);		//高度
	hWnd = GetDesktopWindow();					//整个桌面对应的窗口句柄
	HDC hDC = GetDC(hWnd);						//指定窗口的设备环境
	HDC hdc = CreateCompatibleDC(hDC);		//创建兼容的内存设备环境
	HGDIOBJ h = CreateCompatibleBitmap(hDC, dwScreenWidth, dwScreenHight);	//创建位图
	SelectObject(hdc, h);									//把位图选入指定的内存设备环境中来进行画图
	BitBlt(hdc, 0, 0, dwScreenWidth, dwScreenHight, hDC, 0, 0, 0xCC0020u);	//将需要截图的窗体通过设备对象将图像数据传输到指定兼容的内存设备对象中
	GetObject(h, sizeof(BITMAP), &bmpScreen);	//将位图信息填入bmpScreen中
	bi.biSize = sizeof(BITMAPINFOHEADER);	//填写位图头结构
    bi.biWidth = bmpScreen.bmWidth;
    bi.biHeight = bmpScreen.bmHeight;
    bi.biPlanes = 1;
    bi.biBitCount = 32;
    bi.biCompression = BI_RGB;
    bi.biSizeImage = 0;
    bi.biXPelsPerMeter = 0;
    bi.biYPelsPerMeter = 0;
    bi.biClrUsed = 0;
    bi.biClrImportant = 0;

	dwBmpSize = ((bmpScreen.bmWidth * bi.biBitCount + 31) / 32) * 4 * bmpScreen.bmHeight;		//位图大小
	hDIB = GlobalAlloc(GHND, dwBmpSize);	//申请堆内存填写位图数据
    lpbitmap = (char *)GlobalLock(hDIB);
	//将截图数据写到堆内存中
	GetDIBits(
        hDC,  // 设备环境句柄
       (HBITMAP)h,  // 位图句柄
        0,          // 指定检索的第一个扫描线
        (UINT)bmpScreen.bmHeight, // 指定检索的扫描线数
        lpbitmap,   // 指向用来检索位图数据的缓冲区的指针
        (BITMAPINFO *)&bi, // 该结构体保存位图的数据格式
        DIB_RGB_COLORS // 颜色表由红、绿、蓝（RGB）三个直接值构成
    );
	
	wsprintf(FilePath, "%s\\%s.bmp", "c:\\Users\\xiongchaochao\\Desktop\\", "dump");
	// 创建一个文件来保存文件截图
    hFile = CreateFile(
                FilePath,
                GENERIC_WRITE,
                0,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
            );
	// 将 图片头(headers)的大小, 加上位图的大小来获得整个文件的大小
    int dwSizeofDIB = dwBmpSize + sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER);
 
    // 设置 Offset 偏移至位图的位(bitmap bits)实际开始的地方
    bmfHeader.bfOffBits = (DWORD)sizeof(BITMAPFILEHEADER) + (DWORD)sizeof(BITMAPINFOHEADER);
 
    // 文件大小
    bmfHeader.bfSize = dwSizeofDIB;
 
    // 位图的 bfType 必须是字符串 "BM"
    bmfHeader.bfType = 0x4D42; //BM	
 
    DWORD dwBytesWritten = 0;
    WriteFile(hFile, (LPSTR)&bmfHeader, sizeof(BITMAPFILEHEADER), &dwBytesWritten, NULL);
    WriteFile(hFile, (LPSTR)&bi, sizeof(BITMAPINFOHEADER), &dwBytesWritten, NULL);
    WriteFile(hFile, (LPSTR)lpbitmap, dwBmpSize, &dwBytesWritten, NULL);
 
    // 解锁堆内存并释放
    GlobalUnlock(hDIB);
    GlobalFree(hDIB);
 
    // 关闭文件句柄
    CloseHandle(hFile);
	GlobalUnlock(hDIB);
	GlobalFree(hDIB);
	ReleaseDC(hWnd, hDC);
	DeleteDC(hdc);
	DeleteObject(h);
}
```

## AES加密

AES算法是一个对称分组密码算法。明文数据通过分组进行加密，分组长度固定为128Bit，而密钥长度可以是128、192、256，对于三种不同密钥长度的 AES 算法，分别称为“AES-128”、“AES-192”、“AES-256”。(Rijndael加密法可以支持更大范围的区块和密钥长度,用的密钥和区块长度均可以是128，192或256比特)

![](20141213142619522.png)

- Nk：密钥中包含32bit数据的个数(一列数据4字节，定义为一个32位的字）
- Nb：每组数据包含列的个数(每列32位、一个32位的字)
- Nr：加密的轮数



### 算法流程

![](aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMjE5MTYxMjAyNDg1.jpg)

#### AddRoundKey（轮密钥加）

10轮加密过程前的一步：原始明文个

**每次加密循环中：**

![](320px-AES-AddRoundKey.svg.png)

1. 当前回合密钥与原矩阵数据异或，将值传给下一步进行处理
2. 当前回合密钥经过[Rijndael密钥生成方案](https://zh.wikipedia.org/wiki/Rijndael密钥生成方案)产生下一轮回合密钥

**密钥扩展**

从算法流程看出加密或解密需要11个密钥来进行11次运算，所以我们将原始16字节密钥扩展出10组16字节回合密钥，加上1组原始密钥刚好11组。

1. 将原始密钥输入到一个4x4的矩阵中，接着将每一列看成一个32位字的数组

![1575274941649](1575274941649.png)

2. 通过密钥扩展公式生成回合密钥：

当i如果i不是4的倍数，那么第i列由如下等式确定：
$$
W[i]=W[i-4]⨁W[i-1]
$$
如果i是4的倍数，那么第i列由如下等式确定：
$$
W[i]=W[i-4]⨁T(W[i-1])
$$
其中T是一个复杂的运算函数由3部分组成：

1) 字循环：将1个字中的4个字节循环左移1个字节。即将输入字[b0, b1, b2, b3]变换成[b1,b2,b3,b0]。

2)字节代换：对字循环的结果使用S盒进行字节代换。

2)轮常量异或：字节代换的结果同轮常量Rcon[j]进行异或，j代表轮数

|  j   |   Rcon[j]   |
| :--: | :---------: |
|  1   | 01 00 00 00 |
|  2   | 02 00 00 00 |
|  3   | 04 00 00 00 |
|  4   | 08 00 00 00 |
|  5   | 10 00 00 00 |
|  6   | 20 00 00 00 |
|  7   | 40 00 00 00 |
|  8   | 80 00 00 00 |
|  9   | 1B 00 00 00 |
|  10  | 36 00 00 00 |

![1575275027476](1575275027476.png)

#### 字节代换和逆字节代换

通过查S盒和逆S盒来进行这两个操作。这两个16x16的矩阵是固定的。

将经过轮密钥加后的4x4矩阵的每个字节前4位作为行值，后四位作为列值来输出处理过的数据

#### 行移位和行移位的逆变化

行移位进行左移，逆变化是右移

![行移位](1575276536378.png)

#### 列混合

根据和不同的矩阵进行矩阵乘法来进行列混合和列混合逆运算，二进制乘法也和常规乘法不一样，具体看参考【4】

![列混合](1575277666374.png)

![列混合逆运算](1575277697107.png)

# 参考

【1】[GetDC是什么意思 GetWindowDC(hWnd)](https://www.cnblogs.com/goto/archive/2012/07/19/2599128.html)

【2】[C语言 屏幕截图 (GDI)]([https://lellansin.wordpress.com/2014/03/16/c-gdi-%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE/](https://lellansin.wordpress.com/2014/03/16/c-gdi-屏幕截图/))

【3】[AES加密算法的C++实现](https://songlee24.github.io/2014/12/13/aes-encrypt/)

【4】[AES加密算法的详细介绍与实现](https://blog.csdn.net/qq_28205153/article/details/55798628)