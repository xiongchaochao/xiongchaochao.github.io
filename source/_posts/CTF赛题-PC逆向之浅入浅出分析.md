---
title: CTF赛题-PC逆向之浅入浅出分析
date: 2019-09-26 18:27:54
tags: CTF
---

本篇文章之所以以浅入浅出为标题，其目的是提醒自己在分析过程过切入陷入复杂的细节中，以免丧失信心和兴趣，从而实现快速分析的目标。

# 确定目标

解题

# 实现目标

## 解题流程

1. 了解赛题
2. 确定解题思路
3. 验证解题思路

## 实践过程

文件：ZhonyaRing.rar

来源：看雪CTF-Q3试题（签到题）

### 了解赛题

**赛题要求：**找出用户名`KCTF`对应的序列号

**已知条件：**题目给出了一组用户名和序列号，输入之后打印出`【验证正确！】`

### 确定解题思路

1. 找到`【验证正确！】`字符的位置，向上逆推，分析出需要满足那些条件才可以打印该字段

### 验证解题思路

#### 思路1

##### 逆势而上

**第一个需要满足的条件**：v19和v20两个地址所指向的内容必须满足16字节长度内容的相等

[^wchar_t]: 宽字符，这里是16位

```c
while ( *(_DWORD *)v19 == *(_DWORD *)v20 )
    {
      v19 = (__int128 *)((char *)v19 + 4);
      v20 += 2;
      v12 = v21 < 4;
      v21 -= 4;
      if ( v12 )
      {
        v22 = "【验证正确！】\n\n";
        goto LABEL_22;
      }
    }
```

**v20的值等于aXQxqkv处的常量**，并且再往上分析并没有发现任何对v20和aXQxqkv常量进行修改，所以这就是最终输入内容经过修改后需要比对的内容，接下来分析另一个变量v19

![](1569496489717.png)

v19被赋值为v34的地址，接着由v34来给v16地址进行赋值，而v16的值来源于v29处，最终我们将目光锁定在了`v29 = 1732584193`处，将常量赋值给了v29。不可能两个地址都是常量赋值，中间肯定有操作将其内的数据进行了更改，我们先调试一下，确定被更改的地址是哪个？

```c
 	v29 = 0x67452301;
	.....
	v16 = (char *)&v29 + 1;
 	v11 = 0;
	do
    {
      v18 = *(v16 - 1);
      v16 += 4;
      *((_BYTE *)&v34 + v17) = v18;
      *((_BYTE *)&v34 + v17 + 1) = *(v16 - 4);
      *((_BYTE *)&v34 + v17 + 2) = *(v16 - 3);
      *((_BYTE *)&v34 + v17 + 3) = *(v16 - 2);
      v17 += 4;
    }
    while ( v11 < 0x10 );
	v19 = &v34;
```

（输入的是题中给的用户名和序列号）经过对比，这里的v20的值并未改变，而v19的值很显然从给定的常量值转化成了指定的数据，目标锁定在v29（v19的原始赋值变量）

![](1569498869592.png)

##### 底是谁动了我的v19？

对v19进行交叉引用并没有直接对其进行操作的地方。毫无疑问应该是从它周围的偏移进行修改的，范围扩展。

这时v27进入我们的眼帘，并且引入了v33、sub_1011000、甚至是紧挨着aXQxqkv常量后的地址

![](1569499559000.png)

##### 算法？

首先我们还是将目光锁定在v27。跟进对其直接操作的 sub_1011000函数，跟进入后，全是一些数据运算，很明显是个算法，（以后我会了解它的），这里直接跳过，有经验的多看几眼就能分辨出，我这里在那是只能给它打上未知算法标签。

接下来我们通过调试来大致看看他是在哪改变v29的

![1569499927176](1569499927176.png)

经过调试定位到`sub_1091000((int)&v33, &v27, 8u);`这里，执行后v29地址的值发生了改变。

到这里我们确定了改变v29地址内容的算法函数，并且暂时无法往下深挖，这里我们需要借助别的信息来猜测算法的种类。

![](1569500744475.png)

至此我们分析道最终要的算法位置处，但是还未跟用户输入关联上，我们将目光锁定到这个算法的另一个未知参数v33上。

可以看到v33经过xmmword_10B130C和xmmword_10B12F8两个变量异或128位得到的，接着被传给算法，还经过v27的赋值又传给了算法。先把这两个变量弄清

![1569501569253](1569501569253.png)

xmmword_10B130C变量是16个字符的用户名，而把序列号赋给了v35，从调试结果可以看到将输入内容转成字面意思的16进制值。

![1569501989554](1569501989554.png)

![1569502329722](1569502329722.png)

也就是v33这个变量的值来源于用户名和序列号对应16进制值的异或，异或出字符串`其实我更喜欢孙坚`。

至此我们将输入和关键算法联系上了。先将用户输入的用户名和序列号转成的16进制值异或出一个16字节字符串，接着和v27地址一起被传递给算法函数，然后将算法处理过的值赋值给v29，那么起始没有v27内容的什么事，其主要应该是作为给v29赋值的地址的存在，主要是对用户输入的内容进行了算法运算。

![1569502492538](1569502492538.png)

##### 猜算法

算法将`C6 E4 CA B5 CE D2 B8 FC CF B2 BB B6 CB EF BC E1`转换成了`DA E5 23 10 06 71 95 71  4B A2 CE E2 33 2B B8 66`

一般签到题不会太难，这里应该是常用算法，直接线上MD5试试,很明显是MD5

![1569504232370](1569504232370.png)

##### 小结

本题的思路：将用户名和序列号对应的十六进制内容进行异或，再求MD5值看是否等于`DA E5 23 10 06 71 95 71  4B A2 CE E2 33 2B B8 66`这一串16进制值。

而我们需要做的实现KCTF和序列号异或的值为`C6 E4 CA B5 CE D2 B8 FC CF B2 BB B6 CB EF BC E1`就行。因为KCTF后面是0x00填充，所以只需要满足KCTF和0xC6、0xE4、0xCA、0xB5的异或，在接上`CE D2 B8 FC CF B2 BB B6 CB EF BC E1`，即8DA79EF3CED2B8FCCFB2BBB6CBEFBCE1



