---
title: windows样本高级动态分析三(WinDbg篇)
date: 2019-10-17 17:48:53
tags: windows病毒分析
---

# 前情摘要

## WinDbg功能

1. 用户模式调试
2. 内核模式调试
3. 监控Windows系统交互

## 驱动和内核代码

### 什么是Windows驱动程序？

**概念：**驱动程序是一个软件组织，让操作系统和设备通信。应用程序不能直接从设备中获取数据，而是需要通过驱动程序来去获取。

**分类：**

* 筛选器驱动程序：观察或记录对设备的请求，并将请求传递到堆栈中较低的函数驱动

* 设备函数驱动

  * 直接通信：对于那些直接连接到PCI总线的设备，PCI设备的驱动是直接和PCI设备通信的
  * 间接通信：当设备不直接连接到设备上而是连接到PCI总线主机适配器上时，这个适配器连接着PCI总线和设备直连，这个时候就需要函数驱动程序向适配器发送请求，接着由适配器的函数驱动程序和设备直接通信来返回相应数据

* 软件驱动程序：并不需要获取设备数据，而是为了获取内核模式保护下的数据，所以总是运行在内核模式下。而设备驱动不是为了访问内核中受保护的数据，所以有在用户模式下运行的硬件驱动

### 设备对象

用户态的应用程序不能直接访问驱动程序，需要接着由驱动程序创建的设备对象来通信。

举个栗子：USB闪存设备在系统中有一个处理设备请求的驱动，用户态应用程序是肯定无法访问的。当用户给计算机插上USB闪存设备时，系统给设备创建一个设备对象如"F:"，来让用户态应用程序访问，访问的请求再传给驱动进行处理。

### 驱动加载

驱动程序被加载进内核空间时，DriverEntry函数会被调用，类似于"DllMain"，不同的是驱动不通过函数导出表提供功能接口，而是在DriverEntry中注册回调函数，来提供功能。Windows系统会为每一个驱动程序创建一个驱动对象，并作为参数传给DriverEntry，DriverEntry填充这个对象，接着再创建一个和用户态通信的设备对象。

### 内核恶意代码的行为

没有用户态组件、只是运行在驱动程序中，主要和系统的主要内核组件ntoskrnl.exe（包含系统核心代码）、hal.dll（包含与设备交互的代码）进行交互

## 配置WinDbg调试环境

vmware+win7

1. 关闭虚拟机

2. 如果存在打印机就删除掉，以防占用串口COM_1(如果不想删除，后面配置实用COM_2作为管道串口名称)

3. 添加串行端口，使用`\\.\pipe\com_1`命名，选择`输出到命名管道(M)`，接着如下选项，最后点击完成。然后勾选上I/O模式下的轮训时主动放弃CPU(Y)选项

   ![1571365277231](1571365277231.png)

4. 添加一个开机调试模式的启动选项，并开启虚拟机的内核调试和启用应用程序调试。这个"Windows7"可以自定义，第一步会生成对应ID号，就是下面图中展示的选项

   1. `bcdedit /copy {current} /d "Windwos7"`
   2. `bcdedit /debug {ID} ON`
   3. `bcdedit /bootdebug {ID} ON`
   4. `bcdedit /dbgsettings serial baudrate:115200 debugport:1`

   ![1571369355298](1571369355298.png)

5. 主机上windbg启动设置`-b -k com:port=\\.\pipe\com_1,baud=115200,pipe`。需要将WinDbg启动方式设置为主动连接到虚拟机管道中去。可以加到快捷方式的目标栏

![](1571370594321.png)

​	也可以手动File->kernel Debug->COM，配置如下就行

​	顺便把符号表也加上`srv*d:\symbols*http://msdl.microsoft.com/download/symbols`并且勾选上reload，避免链接到开始内核调试前还需要执行".reload"命令来下载符号，接着就可以从官方下载到d:\symbols文件夹下

![1571378592104](1571378592104.png)

6.开始调试。开机选择调试引导，进入系统，然后在主机里开启WinDbg，点击break随机下断点就进入下图中的调试界面

![1571378760641](1571378760641.png)

## DriverInit

驱动程序的初始化函数，驱动每次被加载都会调用的函数。查看驱动对象结构体的时候会有该函数地址

## 跟踪设备对象

**从用户态如何追踪到驱动程序：**在用户态是通过设备对象和驱动进行通信的，我们根据设备名称，使用"!devobj"来获取设备对象信息中指向驱动程序的指针，进而还可以获得驱动程序的分发函数表。

**哪些用户态程序调用了恶意的驱动程序：**驱动程序创建的设备对象供用户态应用程序来间接通信，所以我们使用"!devhandles"来查看所有用户态进程句柄表，看哪个进程调用了该设备对象，进而使用了恶意驱动程序

## Rootkit

**概念：**隐藏自己的痕迹。一般通过修改操作系统内部函数，具体可以对SSDT系统服务描述符进行挂钩、以及其他技术。

**常见API调用过程：**用户调用到用户态的CreateFile，其下层通过系统调用sysenter结合一个偏移量，进入内核空间查询SSDT中指定偏移位置的函数进行调用。

**SSDT挂钩利用：**该技术可以通过挂钩SSDT表的函数来执行恶意代码

# 1 目标

分析样本学习内核恶意代码：

* 内核层中，通过驱动卸载函数来修改注册表项
* 熟悉WinDbg命令

# 2 流程

1. 基础静态分析
2. 高级静态动态结合分析

# 3 实践

## 3.1 实例

Lab10-01.exe

Lab10-01.sys

### 3.1.1 基础静态分析

#### 3.1.1.1 Lab10-01.exe

结合导入函数和字符串，可能存常见驱动服务的功能

```
导入函数：
StartServiceA
CreateServiceA
ControlService

字符串：
C:\Windows\System32\Lab10-01.sys
```

#### 3.1.1.2 Lab10-01.sys

使用内核函数实现写注册表来修改防火墙配置的一些操作

```
导入函数：
RtlCreateRegistryKey
RtlWriteRegistryValue

字符串：
ntoskrnl.exe
\Registry\Machine\SOFTWARE\Policies\Microsoft\WindowsFirewall\StandardProfile
\Registry\Machine\SOFTWARE\Policies\Microsoft\WindowsFirewall\DomainProfile
\Registry\Machine\SOFTWARE\Policies\Microsoft\WindowsFirewall
```

### 3.1.2 高级动态静态结合分析

Lab10-01.exe的功能很简单就是一个创建开启可执行文件路径为"C:\\Windows\\System32\\Lab10-01.sys"(将文件放在规定目录下才可以创建成功)的服务"Lab10-01"并且根据服务类型可以知道这个是一个驱动服务，开启完成后就发送通知让服务停止并卸载这个驱动服务，也就是说在加载驱动的时候会调用DriverEntry函数，在卸载驱动的时候会调用驱动的DriverUnload函数

![1571801172707](1571801172707.png)

![1571801393094](1571801393094.png)

驱动文件在入口位置向下跟一步会发现这里有一个指令将sub_10486函数地址存放到驱动对象(参数arg_0)偏移0x34位置处,，如果对驱动结构体熟悉的同学可以知道这个偏移刚好是DriverUnload函数的地址，不熟的同学也可以用F5大法来查看,IDA可以帮助我们识别

![1571803776844](1571803776844.png)

![1571803953080](1571803953080.png)

sub_10486函数通过修改注册表键值来关闭防火墙

![1571804408712](1571804408712.png)

可以看到未执行样本我们的防火墙状态处于启用，下面我们动态跟踪一下，看样本的执行过程

![1571804532353](1571804532353.png)

因为要调试驱动程序，涉及到内核调试我们需要进行双机调试。因为刚才静态分析知道程序执行完之后就会卸载驱动服务，所以我们在主机这边只能先下一个延迟断点，断在即将载入驱动的入口位置，这个断点可以用"bu $iment(Lab10_01)"或者"bu Lab10_01 + <入口地址>"来下。

接下来开始下断点，下在驱动服务名为Lab10-01的入口位置，入口点可以在010eidt解析工具查看。（这里WinDbg会将连接符"-"识别成下划线"_"，所以下断点的时候不能使用"Lab10-01"，其他寻址什么的还是用Lab10-01）

![1571819285201](1571819285201.png)

而虚拟机中的那一边，如果我们没有在驱动入口点下断并且找不到卸载函数赋值的地方，这种情况下我们需要将断点下在"call    ds:ControlService"这条指令处，在卸载驱动即执行DriverUnload之前，因为这个时候当断点命中后我们就可以通过查询驱动对象结构体来给卸载函数下断点。

当然啦如果我们可以在驱动入口点下断并且可以找到驱动卸载函数赋值的地方我们就不需要给这个位置下断点了，只需要分析道赋值出就知道了卸载函数的位置接着下断点就行了。反正这里都写上，根据自己需求来下就行了。

在虚拟机中载入PE文件后，我们的PE文件被加载到了0x400000地指处，和PE文件中要求载入的虚拟地址一致，所以直接用IDA解析出的地址就行。这里提一下，如果遇见载入地址和文件中的数据不一致，类似于多个DLL载入内存，我们手动改一下IDA的基地址就行了

![1571820809821](1571820809821.png)

"bp 401080",然后执行起来

![1571821034942](1571821034942.png)

然后我们就会发现虚拟机暂停了怎么也点不动，由于startService函数开始加载驱动文件进入内核，调用到了DriverEntry函数，命中到了我们第一次设置的入口断点。

我们"u 957fe959 L8"反汇编一下地址"957fe959"处的8行汇编指令和IDA反汇编Lab10-01.sys代码对比一下，发现基本一致的，知识写法上windbg用的是符号加偏移，ida直接命名为固定格式的变量名

![1571821582142](1571821582142.png)

然后我们跟到静态分析中分析到的DriverUnload函数赋值处。在赋值之前我们使用"!drvobj Lab10-01"，获取驱动的详细信息，可以看到驱动的地址，也能看到该驱动没有任何设备对象即没有应用层可以和该驱动通信的接口

![1571822172498](1571822172498.png)

然后我们用"dt _DRIVER_OBJECT 8813ff38"命令，用改地址的数据填充驱动对象结构体并展示出来。

可以从驱动名看出识别正确，从0x34偏移处看出这个卸载函数还未进行定义

![1571822398358](1571822398358.png)

在我们执行完赋值后，再次查看结构体，可以看见赋值完成，接着我们给卸载函数下断点，然后"g"执行过去

![1571822553689](1571822553689.png)

可以看到命中的卸载函数和IDA汇编代码一样，只是IDA可以识别出函数符号

![1571827608279](1571827608279.png)

执行完毕后，可以检测到注册表中出现下面的表项和键值

![1571827721565](1571827721565.png)

造成的效果就是防火墙的启用和关闭变成了不可选状态来禁用防火墙

![1571827764368](1571827764368.png)

# 补充知识

**为什么要添加串口：**因为WinDbg通过串口发送特定数据包给被调试的系统，因为Windows本身已经把内核调试机制写进了内核，WinDbg只要通过数据包进行相应的功能访问就行了

**WinDbg命令：**

| 命令                              | 介绍                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| `d*：da/du/dd/`                   | 读取内存数据并以ASCII文本/Unicode文本/32位双字显示。以d开头的命令用于查看内存值。 |
| `dd*/dq*/dp*/d**`                 | 第二位表示指针大小（dd*  使用32位指针，dq*  使用64位指针，dp*  标准大小，32位或64位，取决于CPU）。第三位表示如何解引用内存(`d*a`以ASCII码显示解引用内存，`d*u`以Unicode显示解引用内存) |
| ea/eu/ed address data             | 改变内存的值，以ASCII、Unicode、双字形式                     |
| bp/go(g)                          | 断点/运行                                                    |
| lm                                | 列举加载到进程空间的所有模块（可执行模块、DLL、内核驱动）    |
| u 模块名!函数名                   | 反汇编特定模块的函数                                         |
| bu 模块名!函数名                  | 延迟下断点，当指定模块加载，就给指定函数下断点               |
| bu $iment(模块名)                 | $iment确定模块的入口点，bu延迟下断点                         |
| x                                 | 通配搜索函数或符号。如`x nt!*CreateProcess*`                 |
| ln                                | 列出给定内存地址的符号                                       |
| dt 地址/dt 模块名!结构体符号 地址 | 详细显示指定地址处结构图体的前几行信息后后面粗略的信息/将指定地址的数据填充进结构体并显示 |
| `!drvobj\!object \Driver`         | 显示驱动对象的详细信息/浏览\Driver下所有驱动对象             |
| !devobj                           | 显示设备对象结构的详细信息                                   |

# 参考

【1】[什么是驱动程序？](https://docs.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/what-is-a-driver-)